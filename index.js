//#!/usr/bin/env node
import { input } from "@inquirer/prompts";
import commandLineArgs from "command-line-args";
import fs from "fs";

// Globals
const TEXT = {
  CERTIFICATE: "Файл сертификата .crt",
  REGISTRY: "Файл реестра .reg",
};

const registryRegexp = /\".*\"=hex:((\s*([0-9a-f]{2},?)+)\\?(\r\n)?)+/gm;
const fileNameRegexp = /"(.*?)"/;
const hexBytesRegexp = /hex:(.*?)$/;

const optionDefinitions = [
  { name: "certificate", alias: "c", type: String },
  { name: "registry", alias: "r", type: String },
];

// CLI args setup
const options = commandLineArgs(optionDefinitions);

// UI
const certificatePath =
  options.certificate ?? (await input({ message: TEXT.CERTIFICATE }));
const registryPath =
  options.registry ?? (await input({ message: TEXT.REGISTRY }));

// Load files

const reg = fs.readFileSync(registryPath, { encoding: "utf8", flag: "r" });

// Autogenerated
let m;

!fs.existsSync("./out") && fs.mkdirSync("./out");

while ((m = registryRegexp.exec(reg)) !== null) {
  // This is necessary to avoid infinite loops with zero-width matches
  if (m.index === registryRegexp.lastIndex) {
    registryRegexp.lastIndex++;
  }

  const match = m[0]?.replace(/\r?\n|\t|\s|\\/g, "");

  const fileName = fileNameRegexp.exec(match)?.[1];
  const hex = hexBytesRegexp.exec(match)?.[1];

  if (fileName && hex) {
    const buffer = Buffer.from(hex.split(",").join(""), "hex");
    fs.writeFileSync(`./out/${fileName}`, buffer);
  }
}
